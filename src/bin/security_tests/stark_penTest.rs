use zk_deap::common::{self, AggError};
use zk_deap::stark::IoTDevice;
use std::collections::{HashMap, BTreeMap};
use frost_ristretto255 as frost;
use curve25519_dalek_ng::{ristretto::RistrettoPoint, scalar::Scalar};
use rand::rngs::OsRng;

fn test_stark_reuse_with_different_commitment() {
    println!("\nSubstitution: Reuse valid STARK proof with different Pedersen commitment");
    let (n, t) = (3, 2);
    let (devs, _) = setup_network(n, t).unwrap();
    let honest_proof = devs[0].generate_proof(0).unwrap();
    let different_proof = devs[1].generate_proof(1).unwrap();
    let mut attack_proof = honest_proof.clone();
    attack_proof.elgamal_proof.pedersen_commit = different_proof.elgamal_proof.pedersen_commit;
    attack_proof.device_id = different_proof.device_id;
    attack_proof.timestamp = different_proof.timestamp;
    attack_proof.signature = different_proof.signature;
    let (mut victim_devs, _) = setup_network(n, t).unwrap();
    match victim_devs[2].receive_proof(attack_proof) {Err(AggError::InvalidProof(msg)) if msg.contains("STARK") || msg.contains("verify") => {println!("PASS: Substitution rejected (hash constraint prevents reuse)");},Err(e) => {println!("PASS: Substitution rejected: {:?}", e);},Ok(_) => panic!("FAIL: Substitution attack succeeded. Hash binding broken"),}
}

fn test_stark_substitute_commitment_keep_proof() {
    println!("\nSubstitution: Substitute commitment C with C' while keeping same STARK proof");
    let (n, t) = (3, 2);
    let (devs, _) = setup_network(n, t).unwrap();
    let proof_0 = devs[0].generate_proof(0).unwrap();
    let proof_1 = devs[1].generate_proof(1).unwrap();
    let mut attack_proof = proof_0.clone();
    attack_proof.elgamal_c1 = proof_1.elgamal_c1;
    attack_proof.elgamal_c2 = proof_1.elgamal_c2;
    attack_proof.elgamal_proof.pedersen_commit = proof_1.elgamal_proof.pedersen_commit;
    let (mut victim_devs, _) = setup_network(n, t).unwrap();
    match victim_devs[2].receive_proof(attack_proof) {Err(_) => {println!("PASS: Commitment substitution rejected");},Ok(_) => panic!("FAIL: Commitment substitution succeeded"),}
}

fn test_stark_break_schnorr_link() {
    println!("\nBinding Chain: Valid STARK but invalid Schnorr proof");
    let (n, t) = (3, 2);
    let (devs, _) = setup_network(n, t).unwrap();
    let mut proof = devs[0].generate_proof(1).unwrap();
    let corrupt_scalar = Scalar::random(&mut OsRng);
    proof.elgamal_proof.resp_r = corrupt_scalar.into();
    let (mut victim_devs, _) = setup_network(n, t).unwrap();
    match victim_devs[1].receive_proof(proof) {Err(AggError::InvalidProof(msg)) if msg.contains("Schnorr") || msg.contains("sig") => {println!("PASS: Broken Schnorr link rejected");},Err(_) => {println!("PASS: Broken Schnorr link rejected");},Ok(_) => panic!("FAIL: Broken Schnorr link accepted"),}
}

fn test_stark_break_air_constraint() {
    println!("\nBinding Chain: Valid Schnorr but invalid AIR constraint proof");
    let (n, t) = (3, 2);
    let (devs, _) = setup_network(n, t).unwrap();
    let mut proof = devs[0].generate_proof(1).unwrap();
    proof.stark_proof = vec![0u8; 10000];
    
    let (mut victim_devs, _) = setup_network(n, t).unwrap();
    match victim_devs[1].receive_proof(proof) {Err(_) => {println!("PASS: Invalid STARK proof rejected");},Ok(_) => panic!("FAIL: Invalid STARK proof accepted"),}
}

fn test_stark_skip_linking_proof() {
    println!("\nBinding Chain: Submit without Schnorr linking proof");
    let (n, t) = (3, 2);
    let (devs, _) = setup_network(n, t).unwrap();
    let mut proof = devs[0].generate_proof(1).unwrap();
    proof.elgamal_proof.resp_r = Scalar::zero().into();
    proof.elgamal_proof.resp_state = Scalar::zero().into();
    let (mut victim_devs, _) = setup_network(n, t).unwrap();
    match victim_devs[1].receive_proof(proof) {Err(_) => {println!("PASS: Missing linking proof rejected");},Ok(_) => panic!("FAIL: Proof without linking accepted"),}
}

fn test_stark_constraint_violation_state_5() {
    println!("\nConstraint: Try to prove state=5 (violates binary constraint)");
    let (n, t) = (3, 2);
    let (devs, _) = setup_network(n, t).unwrap();
    match devs[0].generate_proof(5) {Err(AggError::CryptoError(msg)) if msg.contains("State") => {println!("PASS: Invalid state rejected at generation");},Err(_) => {println!("PASS: Invalid state rejected");},Ok(_) => panic!("FAIL: Proof generated for invalid state"),}}

fn test_stark_hash_gate_violation() {
    println!("\nConstraint: Try to satisfy hash gate but violate binary constraint");
    let (n, t) = (3, 2);
    let (devs, _) = setup_network(n, t).unwrap();
    let mut proof = devs[0].generate_proof(1).unwrap();
    if proof.stark_commitment.len() == 16 {
        proof.stark_commitment[8] = 255;
        proof.stark_commitment[9] = 255;
    }
    let (mut victim_devs, _) = setup_network(n, t).unwrap();
    match victim_devs[1].receive_proof(proof) {Err(_) => {println!("PASS: Hash gate violation rejected");},Ok(_) => panic!("FAIL: Hash gate violation accepted"),}
}

fn test_stark_malleability_modify_bytes() {
    println!("\nMalleability: Modify STARK proof bytes");
    let (n, t) = (3, 2);
    let (devs, _) = setup_network(n, t).unwrap();
    let mut proof = devs[0].generate_proof(1).unwrap();
    if proof.stark_proof.len() > 1000 {
        proof.stark_proof[500] ^= 0x01;
        proof.stark_proof[501] ^= 0xFF;
    }
    let (mut victim_devs, _) = setup_network(n, t).unwrap();
    match victim_devs[1].receive_proof(proof) {Err(_) => {println!("PASS: Modified proof bytes rejected");},Ok(_) => panic!("FAIL: Modified proof accepted"),}
}

fn test_stark_transcript_domain_separation() {
    println!("\nMalleability: Transcript domain separation");
    let (n, t) = (3, 2);
    let (devs, _) = setup_network(n, t).unwrap();
    let mut proof = devs[0].generate_proof(1).unwrap();
    proof.timestamp = proof.timestamp + 1;
    let (mut victim_devs, _) = setup_network(n, t).unwrap();
    match victim_devs[1].receive_proof(proof) {Err(_) => {println!("PASS: Transcript tampering detected (signature fails)");},Ok(_) => panic!("FAIL: Modified transcript accepted"),}
}

fn test_stark_signature_forgery() {
    println!("\nSignature: Submit without valid EdDSA signature");
    let (n, t) = (3, 2);
    let (devs, _) = setup_network(n, t).unwrap();
    let mut proof = devs[0].generate_proof(0).unwrap();
    proof.signature = [42u8; 64];
    let (mut victim_devs, _) = setup_network(n, t).unwrap();
    match victim_devs[1].receive_proof(proof) {Err(AggError::InvalidProof(msg)) if msg.contains("sig") => {println!("PASS: Signature forgery rejected");},Err(_) => {println!("PASS: Signature forgery rejected");},Ok(_) => panic!("FAIL: Forged signature accepted"),}
}

fn test_stark_wrong_device_signature() {
    println!("\nSignature: Use signature from wrong device");
    let (n, t) = (3, 2);
    let (devs, _) = setup_network(n, t).unwrap();
    let proof_0 = devs[0].generate_proof(1).unwrap();
    let proof_1 = devs[1].generate_proof(1).unwrap();
    let mut attack_proof = proof_0;
    attack_proof.signature = proof_1.signature;
    let (mut victim_devs, _) = setup_network(n, t).unwrap();
    match victim_devs[2].receive_proof(attack_proof) {Err(_) => {println!("PASS: Wrong device signature rejected");},Ok(_) => panic!("FAIL: Wrong device signature accepted"),}
}

fn test_stark_modify_after_signing() {
    println!("\nSignature: Modify proof after signing");
    let (n, t) = (3, 2);
    let (devs, _) = setup_network(n, t).unwrap();
    let mut proof = devs[0].generate_proof(1).unwrap();
    let modified_point = RistrettoPoint::random(&mut OsRng);
    proof.elgamal_c1 = modified_point.compress().into();
    let (mut victim_devs, _) = setup_network(n, t).unwrap();
    match victim_devs[1].receive_proof(proof) {Err(_) => {println!("PASS: Modified-after-signing rejected");},Ok(_) => panic!("FAIL: Modified proof accepted"),}
}

fn test_stark_nonce_replay() {
    println!("\nReplay: Resubmit identical proof (nonce check)");
    let (n, t) = (3, 2);
    let (mut devs, _) = setup_network(n, t).unwrap();
    let proof = devs[0].generate_proof(1).unwrap();
    devs[1].receive_proof(proof.clone()).unwrap();
    match devs[1].receive_proof(proof) {Err(AggError::InvalidProof(msg)) if msg.contains("Nonce") || msg.contains("Duplicate") => {println!("PASS: Nonce replay rejected");},Err(_) => {println!("PASS: Nonce replay rejected");},Ok(_) => panic!("FAIL: Replay attack succeeded"),}
}

fn test_stark_future_timestamp() {
    println!("\nTimestamp: Submit with future timestamp");
    let (n, t) = (3, 2);
    let (mut devs, _) = setup_network(n, t).unwrap();
    let mut proof = devs[0].generate_proof(0).unwrap();
    proof.timestamp = proof.timestamp + 1000000;
    match devs[1].receive_proof(proof) {Err(AggError::InvalidProof(msg)) if msg.contains("Timestamp") || msg.contains("future") => {println!("PASS: Future timestamp rejected");},Err(_) => {println!("PASS: Future timestamp rejected");},Ok(_) => panic!("FAIL: Future timestamp accepted"),}
}

fn test_stark_expired_timestamp() {
    println!("\nTimestamp: Submit with expired timestamp");
    let (n, t) = (3, 2);
    let (mut devs, _) = setup_network(n, t).unwrap();
    let mut proof = devs[0].generate_proof(0).unwrap();
    proof.timestamp = 1000;
    match devs[1].receive_proof(proof) {Err(AggError::ExpiredProof) => {println!("PASS: Expired timestamp rejected");},Err(_) => {println!("PASS: Expired timestamp rejected");},Ok(_) => panic!("FAIL: Expired timestamp accepted"),}
}

fn test_stark_honest_execution() {
    println!("\nHonest protocol execution should SUCCEED");
    let (n, t) = (5, 3);
    let (mut devs, states) = setup_network(n, t).unwrap();
    let mut proofs = Vec::new();
    for i in 0..n {
        let state = states[i];
        let proof = devs[i].generate_proof(state).unwrap();
        proofs.push(proof);
    }
    for proof in proofs {
        for d in devs.iter_mut() {
            d.receive_proof(proof.clone()).unwrap();
        }
    }
    let mut partials = Vec::new();
    for i in 0..t {
        let partial = devs[i].generate_partial_decryption().unwrap();
        partials.push(partial);
    }
    for partial in partials {
        for d in devs.iter_mut() {
            d.receive_partial(partial.clone()).ok();
        }
    }
    let expected_sum = states.iter().take(n).map(|&s| s as usize).sum::<usize>();
    match devs[0].compute_aggregate() {Ok((sum, total)) if sum == expected_sum && total == n => {println!("PASS: Honest execution succeeded (sum={}/{})", sum, total);},Ok((sum, total)) => panic!("FAIL: Wrong result: {}/{} != {}/{}", sum, total, expected_sum, n),Err(e) => panic!("FAIL: Honest execution failed: {:?}", e),}
}

fn setup_network(n: usize, t: usize) -> Result<(Vec<IoTDevice>, Vec<u8>), AggError> {
    let states = vec![1u8, 0, 1, 1, 0];
    let mut r1_secrets = Vec::new();
    let mut r1_packages = BTreeMap::new();
    for i in 1..=n {
        let (secret, package) = common::dkg_phase1(i as u32, n, t)?;
        let id = frost::Identifier::try_from(i as u16).map_err(|e| AggError::CryptoError(e.to_string()))?;
        r1_secrets.push((i as u32, secret));
        r1_packages.insert(id, package);
    }
    let mut r2_secrets = Vec::new();
    let mut r2_packages_map = HashMap::new();
    for (device_id, r1_secret) in &r1_secrets {
        let my_id = frost::Identifier::try_from(*device_id as u16).map_err(|e| AggError::CryptoError(e.to_string()))?;
        let mut received_r1 = r1_packages.clone();
        received_r1.remove(&my_id);
        let (r2_secret, r2_packages) = common::dkg_phase2(r1_secret.clone(), &received_r1)?;
        r2_secrets.push((*device_id, r2_secret));
        r2_packages_map.insert(*device_id, r2_packages);
    }
    let mut dkg = Vec::new();
    for (device_id, r2_secret) in &r2_secrets {
        let my_id = frost::Identifier::try_from(*device_id as u16).map_err(|e| AggError::CryptoError(e.to_string()))?;
        let mut received_r2 = BTreeMap::new();
        for (other_id, packages) in &r2_packages_map {
            if other_id != device_id {
                if let Some(pkg) = packages.get(&my_id) {
                    let other_frost_id = frost::Identifier::try_from(*other_id as u16).map_err(|e| AggError::CryptoError(e.to_string()))?;
                    received_r2.insert(other_frost_id, pkg.clone());
                }
            }
        }
        let mut all_r1 = r1_packages.clone();
        all_r1.remove(&my_id);
        let (key_package, public_key_package) = common::dkg_phase3(&r2_secret, &all_r1, &received_r2)?;
        dkg.push((*device_id, key_package, public_key_package));
    }
    let mut devs = Vec::new();
    let mut all_keys = HashMap::new();
    for (id, kpkg, ppkg) in &dkg {
        let d = IoTDevice::new(*id, t, kpkg.clone(), ppkg.clone(), HashMap::new(), None)?;
        all_keys.insert(*id, d.sig_key.verifying_key());
        devs.push(d);
    }
    for d in devs.iter_mut() {
        d.peer_keys = all_keys.clone();
        d.valid_participant_ids.clear();
        d.valid_participant_ids.insert(d.id);
        for peer_id in d.peer_keys.keys() {
            d.valid_participant_ids.insert(*peer_id);
        }
    }
    Ok((devs, states))
}

fn main() {
    println!("STARK ADVERSARIAL TESTS");
    let tests: Vec<(&str, fn())> = vec![
        ("Substitution: Reuse with different commitment", test_stark_reuse_with_different_commitment),
        ("Substitution: Commitment substitution", test_stark_substitute_commitment_keep_proof),
        ("Binding Chain: Break Schnorr link", test_stark_break_schnorr_link),
        ("Binding Chain: Break AIR constraint", test_stark_break_air_constraint),
        ("Binding Chain: Skip linking proof", test_stark_skip_linking_proof),
        ("Constraint: State=5 violation", test_stark_constraint_violation_state_5),
        ("Constraint: Hash gate violation", test_stark_hash_gate_violation),
        ("Malleability: Modify bytes", test_stark_malleability_modify_bytes),
        ("Malleability: Transcript domain", test_stark_transcript_domain_separation),
        ("Signature: Forgery", test_stark_signature_forgery),
        ("Signature: Wrong device", test_stark_wrong_device_signature),
        ("Signature: Modify after signing", test_stark_modify_after_signing),
        ("Replay: Nonce replay", test_stark_nonce_replay),
        ("Timestamp: Future", test_stark_future_timestamp),
        ("Timestamp: Expired", test_stark_expired_timestamp),
        ("CONTROL: Honest execution", test_stark_honest_execution),
    ];
    let mut passed = 0;
    let mut failed = 0;
    for (name, test_fn) in tests {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(test_fn)) {Ok(_) => {passed += 1;}Err(e) => {if let Some(s) = e.downcast_ref::<String>() {println!("FAILED: {} - {}", name, s);} else if let Some(s) = e.downcast_ref::<&str>() {println!("FAILED: {} - {}", name, s);} else {println!("FAILED: {}", name);}failed += 1;}}
    }
    println!("\nRESULTS: {} passed, {} failed", passed, failed);
}