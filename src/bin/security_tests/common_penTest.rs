use zk_deap::common::{self, AggError, VerifiedCiphertext, VerifiedPartial};
use zk_deap::bulletproof;
use std::collections::{HashMap, BTreeMap};
use frost_ristretto255 as frost;
use curve25519_dalek_ng::{ristretto::RistrettoPoint, scalar::Scalar};
use rand::rngs::OsRng;

fn test_threshold_insufficient_t_minus_1() {
    println!("\nThreshold: t-1 partials should FAIL");
    let (n, t) = (5, 3);
    let (mut devs, states) = setup_network(n, t).unwrap();
    for (i, &state) in states.iter().enumerate() {
        let proof = devs[i].generate_proof(state).unwrap();
        for d in devs.iter_mut() {
            d.receive_proof(proof.clone()).unwrap();
        }
    }
    let mut all_partials = Vec::new();
    for i in 0..(t-1) {
        let partial = devs[i].generate_partial_decryption().unwrap();
        all_partials.push(partial);
    }
    let verified_ciphertexts: Vec<VerifiedCiphertext> = devs[0].verified_ciphertexts.values().cloned().collect();
    let verified_partials: Vec<VerifiedPartial> = all_partials.iter().map(|p| {VerifiedPartial {device_id: p.device_id,timestamp: p.timestamp,partial: p.partial.0.decompress().unwrap(),}}).collect();
    match common::compute_aggregate(t, &verified_ciphertexts, &verified_partials) {Err(AggError::ThresholdNotMet) => {println!("PASS: t-1 partials properly rejected");},Ok(_) => panic!("FAIL: Decryption succeeded with insufficient shares"),Err(e) => panic!("FAIL: Wrong error: {:?}", e),}
}

fn test_threshold_exact_t() {
    println!("\nThreshold: Exactly t partials should SUCCEED");
    let (n, t) = (5, 3);
    let (mut devs, states) = setup_network(n, t).unwrap();
    for (i, &state) in states.iter().enumerate() {
        let proof = devs[i].generate_proof(state).unwrap();
        for d in devs.iter_mut() {
            d.receive_proof(proof.clone()).unwrap();
        }
    }
    let mut all_partials = Vec::new();
    for i in 0..t {
        let partial = devs[i].generate_partial_decryption().unwrap();
        all_partials.push(partial);
    }
    let verified_ciphertexts: Vec<VerifiedCiphertext> = devs[0].verified_ciphertexts.values().cloned().collect();
    let verified_partials: Vec<VerifiedPartial> = all_partials.iter().map(|p| {VerifiedPartial {device_id: p.device_id,timestamp: p.timestamp,partial: p.partial.0.decompress().unwrap(),}}).collect();
    match common::compute_aggregate(t, &verified_ciphertexts, &verified_partials) {Ok((sum, total)) => {let expected = states.iter().map(|&s| s as usize).sum::<usize>();assert_eq!(sum, expected, "FAIL: Wrong aggregate");assert_eq!(total, n, "FAIL: Wrong total");println!("PASS: t partials succeeded with correct aggregate ({})", sum);},Err(e) => panic!("FAIL: Should succeed with t shares: {:?}", e),}
}

fn test_threshold_excess_t_plus_1() {
    println!("\nThreshold: t+1 partials should SUCCEED");
    let (n, t) = (5, 3);
    let (mut devs, states) = setup_network(n, t).unwrap();
    for (i, &state) in states.iter().enumerate() {
        let proof = devs[i].generate_proof(state).unwrap();
        for d in devs.iter_mut() {
            d.receive_proof(proof.clone()).unwrap();
        }
    }
    let mut all_partials = Vec::new();
    for i in 0..(t+1) {
        let partial = devs[i].generate_partial_decryption().unwrap();
        all_partials.push(partial);
    }
    let verified_ciphertexts: Vec<VerifiedCiphertext> = devs[0].verified_ciphertexts.values().cloned().collect();
    let verified_partials: Vec<VerifiedPartial> = all_partials.iter().map(|p| {VerifiedPartial {device_id: p.device_id,timestamp: p.timestamp,partial: p.partial.0.decompress().unwrap(),}}).collect();
    match common::compute_aggregate(t, &verified_ciphertexts, &verified_partials) {Ok((sum, _)) => {let expected = states.iter().map(|&s| s as usize).sum::<usize>();assert_eq!(sum, expected);println!("PASS: t+1 partials succeeded with correct aggregate");},Err(e) => panic!("FAIL: Should succeed with t+1 shares: {:?}", e),}
}

fn test_chaum_pedersen_corrupted_partial() {
    println!("\nChaum-Pedersen: Corrupted partial point should FAIL");
    let (n, t) = (4, 2);
    let (mut devs, states) = setup_network(n, t).unwrap();
    for (i, &state) in states.iter().take(n).enumerate() {
        let proof = devs[i].generate_proof(state).unwrap();
        for d in devs.iter_mut() {
            d.receive_proof(proof.clone()).unwrap();
        }
    }
    let mut partial = devs[0].generate_partial_decryption().unwrap();
    let random_point = RistrettoPoint::random(&mut OsRng);
    partial.partial = random_point.compress().into();
    let verified_ciphertexts: Vec<VerifiedCiphertext> = devs[1].verified_ciphertexts.values().cloned().collect();
    let mut verified_partials: Vec<VerifiedPartial> = Vec::new();
    let mut rates = HashMap::new();
    match common::receive_partial(partial,&devs[1].peer_keys,&devs[1].group_pub,&verified_ciphertexts,&mut verified_partials,&mut rates,) {Err(AggError::InvalidProof(msg)) if msg.contains("Schnorr") || msg.contains("proof") => {println!("Corrupted partial rejected by Chaum-Pedersen");},Err(e) => println!("PASS: Corrupted partial rejected: {:?}", e),Ok(_) => panic!("FAIL: Corrupted partial accepted"),}
}

fn test_chaum_pedersen_wrong_device_id() {
    println!("\nChaum-Pedersen: Wrong device ID should FAIL");
    let (n, t) = (4, 2);
    let (mut devs, states) = setup_network(n, t).unwrap();
    for (i, &state) in states.iter().take(n).enumerate() {
        let proof = devs[i].generate_proof(state).unwrap();
        for d in devs.iter_mut() {
            d.receive_proof(proof.clone()).unwrap();
        }
    }
    let mut partial = devs[0].generate_partial_decryption().unwrap();
    partial.device_id = 2;
    let verified_ciphertexts: Vec<VerifiedCiphertext> = devs[1].verified_ciphertexts.values().cloned().collect();
    let mut verified_partials: Vec<VerifiedPartial> = Vec::new();
    let mut rates = HashMap::new();
    match common::receive_partial(partial,&devs[1].peer_keys,&devs[1].group_pub,&verified_ciphertexts,&mut verified_partials,&mut rates,) {Err(_) => println!("PASS: Wrong device ID rejected"),Ok(_) => panic!("FAIL: Wrong device ID accepted"),}
}

fn test_chaum_pedersen_forged_proof() {
    println!("\nChaum-Pedersen: Forged proof components should FAIL");
    let (n, t) = (4, 2);
    let (mut devs, states) = setup_network(n, t).unwrap();
    for (i, &state) in states.iter().take(n).enumerate() {
        let proof = devs[i].generate_proof(state).unwrap();
        for d in devs.iter_mut() {
            d.receive_proof(proof.clone()).unwrap();
        }
    }
    let mut partial = devs[0].generate_partial_decryption().unwrap();
    let forged_scalar = Scalar::random(&mut OsRng);
    partial.proof.response = forged_scalar.into();
    let verified_ciphertexts: Vec<VerifiedCiphertext> = devs[1].verified_ciphertexts.values().cloned().collect();
    let mut verified_partials: Vec<VerifiedPartial> = Vec::new();
    let mut rates = HashMap::new();
    match common::receive_partial(partial,&devs[1].peer_keys,&devs[1].group_pub,&verified_ciphertexts,&mut verified_partials,&mut rates,) {Err(AggError::InvalidProof(msg)) if msg.contains("Schnorr") => {println!("PASS: Forged Chaum-Pedersen proof rejected");},Err(e) => println!("PASS: Forged proof rejected: {:?}", e),Ok(_) => panic!("FAIL: Forged proof accepted")}
}

fn test_chaum_pedersen_malicious_not_affecting_aggregate() {
    println!("\nChaum-Pedersen: Malicious partials don't affect aggregate");
    let (n, t) = (5, 3);
    let (mut devs, states) = setup_network(n, t).unwrap();
    for (i, &state) in states.iter().enumerate() {
        let proof = devs[i].generate_proof(state).unwrap();
        for d in devs.iter_mut() {
            d.receive_proof(proof.clone()).unwrap();
        }
    }
    let mut malicious_partial = devs[0].generate_partial_decryption().unwrap();
    malicious_partial.partial = RistrettoPoint::random(&mut OsRng).compress().into();
    let verified_ciphertexts: Vec<VerifiedCiphertext> = devs[1].verified_ciphertexts.values().cloned().collect();
    let mut verified_partials: Vec<VerifiedPartial> = Vec::new();
    let mut rates = HashMap::new();
    let _ = common::receive_partial(malicious_partial,&devs[1].peer_keys,&devs[1].group_pub,&verified_ciphertexts,&mut verified_partials,&mut rates,);
    for i in 1..=t {
        let partial = devs[i].generate_partial_decryption().unwrap();
        let _verified = common::receive_partial(partial,&devs[1].peer_keys,&devs[1].group_pub,&verified_ciphertexts,&mut verified_partials,&mut rates,).unwrap();
    }
    match common::compute_aggregate(t, &verified_ciphertexts, &verified_partials) {Ok((sum, _)) => {let expected = states.iter().map(|&s| s as usize).sum::<usize>();assert_eq!(sum, expected);println!("PASS: Malicious partial didn't affect aggregate");},Err(e) => panic!("FAIL: Aggregate failed: {:?}", e),}
}

fn test_partial_signature_forgery() {
    println!("\nPartial Signature: Forged signature should FAIL");
    let (n, t) = (4, 2);
    let (mut devs, states) = setup_network(n, t).unwrap();
    for (i, &state) in states.iter().take(n).enumerate() {
        let proof = devs[i].generate_proof(state).unwrap();
        for d in devs.iter_mut() {
            d.receive_proof(proof.clone()).unwrap();
        }
    }
    let mut partial = devs[0].generate_partial_decryption().unwrap();
    partial.signature = [42u8; 64];
    let verified_ciphertexts: Vec<VerifiedCiphertext> = devs[1].verified_ciphertexts.values().cloned().collect();
    let mut verified_partials: Vec<VerifiedPartial> = Vec::new();
    let mut rates = HashMap::new();
    match common::receive_partial(partial,&devs[1].peer_keys,&devs[1].group_pub,&verified_ciphertexts,&mut verified_partials,&mut rates,) {Err(AggError::InvalidProof(msg)) if msg.contains("sig") => {println!("PASS: Forged signature rejected");},Err(e) => println!("PASS: Forged signature rejected: {:?}", e),Ok(_) => panic!("FAIL: Forged signature accepted"),}
}

fn test_partial_wrong_device_signature() {
    println!("\nPartial Signature: Wrong device signature should FAIL");
    let (n, t) = (4, 2);
    let (mut devs, states) = setup_network(n, t).unwrap();
    for (i, &state) in states.iter().take(n).enumerate() {
        let proof = devs[i].generate_proof(state).unwrap();
        for d in devs.iter_mut() {
            d.receive_proof(proof.clone()).unwrap();
        }
    }
    let partial_0 = devs[0].generate_partial_decryption().unwrap();
    let partial_1 = devs[1].generate_partial_decryption().unwrap();
    let mut attack_partial = partial_0;
    attack_partial.signature = partial_1.signature;
    let verified_ciphertexts: Vec<VerifiedCiphertext> = devs[2].verified_ciphertexts.values().cloned().collect();
    let mut verified_partials: Vec<VerifiedPartial> = Vec::new();
    let mut rates = HashMap::new();
    match common::receive_partial(attack_partial,&devs[2].peer_keys,&devs[2].group_pub,&verified_ciphertexts,&mut verified_partials,&mut rates,) {Err(_) => println!("PASS: Wrong device signature rejected"),Ok(_) => panic!("FAIL: Wrong device signature accepted"),}
}

fn test_partial_modify_after_signing() {
    println!("\nPartial Signature: Modify after signing should FAIL");
    let (n, t) = (4, 2);
    let (mut devs, states) = setup_network(n, t).unwrap();
    for (i, &state) in states.iter().take(n).enumerate() {
        let proof = devs[i].generate_proof(state).unwrap();
        for d in devs.iter_mut() {
            d.receive_proof(proof.clone()).unwrap();
        }
    }
    let mut partial = devs[0].generate_partial_decryption().unwrap();
    let modified_point = RistrettoPoint::random(&mut OsRng);
    partial.partial = modified_point.compress().into();
    let verified_ciphertexts: Vec<VerifiedCiphertext> = devs[1].verified_ciphertexts.values().cloned().collect();
    let mut verified_partials: Vec<VerifiedPartial> = Vec::new();
    let mut rates = HashMap::new();
    match common::receive_partial(partial,&devs[1].peer_keys,&devs[1].group_pub,&verified_ciphertexts,&mut verified_partials,&mut rates,) {Err(_) => println!("PASS: Modified-after-signing rejected"),Ok(_) => panic!("FAIL: Modified partial accepted"),}
}

fn test_partial_future_timestamp() {
    println!("\nTimestamp: Future timestamp should FAIL");
    let (n, t) = (4, 2);
    let (mut devs, states) = setup_network(n, t).unwrap();
    for (i, &state) in states.iter().take(n).enumerate() {
        let proof = devs[i].generate_proof(state).unwrap();
        for d in devs.iter_mut() {
            d.receive_proof(proof.clone()).unwrap();
        }
    }
    let mut partial = devs[0].generate_partial_decryption().unwrap();
    partial.timestamp = partial.timestamp + 1000000;
    let verified_ciphertexts: Vec<VerifiedCiphertext> = devs[1].verified_ciphertexts.values().cloned().collect();
    let mut verified_partials: Vec<VerifiedPartial> = Vec::new();
    let mut rates = HashMap::new();
    match common::receive_partial(partial,&devs[1].peer_keys,&devs[1].group_pub,&verified_ciphertexts,&mut verified_partials,&mut rates,) {Err(AggError::InvalidProof(msg)) if msg.contains("future") => {println!("PASS: Future timestamp rejected");},Err(_) => println!("PASS: Future timestamp rejected"),Ok(_) => panic!("FAIL: Future timestamp accepted"),}
}

fn test_partial_expired_timestamp() {
    println!("\nTimestamp: Expired timestamp should FAIL");
    let (n, t) = (4, 2);
    let (mut devs, states) = setup_network(n, t).unwrap();
    for (i, &state) in states.iter().take(n).enumerate() {
        let proof = devs[i].generate_proof(state).unwrap();
        for d in devs.iter_mut() {
            d.receive_proof(proof.clone()).unwrap();
        }
    }
    let mut partial = devs[0].generate_partial_decryption().unwrap();
    partial.timestamp = 1000;
    let verified_ciphertexts: Vec<VerifiedCiphertext> = devs[1].verified_ciphertexts.values().cloned().collect();
    let mut verified_partials: Vec<VerifiedPartial> = Vec::new();
    let mut rates = HashMap::new();
    match common::receive_partial(partial,&devs[1].peer_keys,&devs[1].group_pub,&verified_ciphertexts,&mut verified_partials,&mut rates,) {Err(AggError::ExpiredProof) => {println!("PASS: Expired timestamp rejected");},Err(e) => println!("PASS: Expired timestamp rejected: {:?}", e),Ok(_) => panic!("FAIL: Expired timestamp accepted"),}
}

fn test_honest_threshold_execution() {
    println!("\nHonest threshold execution should SUCCEED");
    let (n, t) = (5, 3);
    let (mut devs, states) = setup_network(n, t).unwrap();
    for (i, &state) in states.iter().enumerate() {
        let proof = devs[i].generate_proof(state).unwrap();
        for d in devs.iter_mut() {
            d.receive_proof(proof.clone()).unwrap();
        }
    }
    for i in 0..t {
        let partial = devs[i].generate_partial_decryption().unwrap();
        for d in devs.iter_mut() {
            d.receive_partial(partial.clone()).ok();
        }
    }
    let expected_sum = states.iter().map(|&s| s as usize).sum::<usize>();
    match devs[0].compute_aggregate() {Ok((sum, total)) if sum == expected_sum && total == n => {println!("PASS: Honest execution succeeded (sum={}/{})", sum, total);},Ok((sum, total)) => panic!("FAIL: Wrong result: {}/{} != {}/{}", sum, total, expected_sum, n),Err(e) => panic!("FAIL: Honest execution failed: {:?}", e),}
}
fn setup_network(n: usize, t: usize) -> Result<(Vec<bulletproof::IoTDevice>, Vec<u8>), AggError> {
    let states = vec![1u8, 0, 1, 1, 0];
    let mut r1_secrets = Vec::new();
    let mut r1_packages = BTreeMap::new();
    for i in 1..=n {
        let (secret, package) = common::dkg_phase1(i as u32, n, t)?;
        let id = frost::Identifier::try_from(i as u16).map_err(|e| AggError::CryptoError(e.to_string()))?;
        r1_secrets.push((i as u32, secret));
        r1_packages.insert(id, package);
    }
    let mut r2_secrets = Vec::new();
    let mut r2_packages_map = HashMap::new();
    for (device_id, r1_secret) in &r1_secrets {
        let my_id = frost::Identifier::try_from(*device_id as u16).map_err(|e| AggError::CryptoError(e.to_string()))?;
        let mut received_r1 = r1_packages.clone();
        received_r1.remove(&my_id);
        let (r2_secret, r2_packages) = common::dkg_phase2(r1_secret.clone(), &received_r1)?;
        r2_secrets.push((*device_id, r2_secret));
        r2_packages_map.insert(*device_id, r2_packages);
    }
    let mut dkg = Vec::new();
    for (device_id, r2_secret) in &r2_secrets {
        let my_id = frost::Identifier::try_from(*device_id as u16).map_err(|e| AggError::CryptoError(e.to_string()))?;
        let mut received_r2 = BTreeMap::new();
        for (other_id, packages) in &r2_packages_map {
            if other_id != device_id {
                if let Some(pkg) = packages.get(&my_id) {
                    let other_frost_id = frost::Identifier::try_from(*other_id as u16).map_err(|e| AggError::CryptoError(e.to_string()))?;
                    received_r2.insert(other_frost_id, pkg.clone());
                }
            }
        }
        let mut all_r1 = r1_packages.clone();
        all_r1.remove(&my_id);
        let (key_package, public_key_package) = common::dkg_phase3(&r2_secret, &all_r1, &received_r2)?;
        dkg.push((*device_id, key_package, public_key_package));
    }
    let mut devs = Vec::new();
    let mut all_keys = HashMap::new();
    for (id, kpkg, ppkg) in &dkg {
        let d = bulletproof::IoTDevice::new(*id, t, kpkg.clone(), ppkg.clone(), HashMap::new(), None)?;
        all_keys.insert(*id, d.sig_key.verifying_key());
        devs.push(d);
    }
    for d in devs.iter_mut() {
        d.peer_keys = all_keys.clone();
        d.valid_participant_ids.clear();
        d.valid_participant_ids.insert(d.id);
        for peer_id in d.peer_keys.keys() {
            d.valid_participant_ids.insert(*peer_id);
        }
    }
    Ok((devs, states))
}

fn main() {
    println!("COMMON CODE ADVERSARIAL TESTS");
    let tests: Vec<(&str, fn())> = vec![
        ("Threshold: t-1 should FAIL", test_threshold_insufficient_t_minus_1),
        ("Threshold: t should SUCCEED", test_threshold_exact_t),
        ("Threshold: t+1 should SUCCEED", test_threshold_excess_t_plus_1),
        ("Chaum-Pedersen: Corrupted partial", test_chaum_pedersen_corrupted_partial),
        ("Chaum-Pedersen: Wrong device ID", test_chaum_pedersen_wrong_device_id),
        ("Chaum-Pedersen: Forged proof", test_chaum_pedersen_forged_proof),
        ("Chaum-Pedersen: Malicious not affecting aggregate", test_chaum_pedersen_malicious_not_affecting_aggregate),
        ("Partial Signature: Forgery", test_partial_signature_forgery),
        ("Partial Signature: Wrong device", test_partial_wrong_device_signature),
        ("Partial Signature: Modify after signing", test_partial_modify_after_signing),
        ("Timestamp: Future timestamp", test_partial_future_timestamp),
        ("Timestamp: Expired timestamp", test_partial_expired_timestamp),
        ("CONTROL: Honest execution", test_honest_threshold_execution),
    ];
    let mut passed = 0;
    let mut failed = 0;
    for (name, test_fn) in tests {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(test_fn)) {Ok(_) => {passed += 1;}Err(e) => {if let Some(s) = e.downcast_ref::<String>() {println!("FAILED: {} - {}", name, s);} else if let Some(s) = e.downcast_ref::<&str>() {println!("FAILED: {} - {}", name, s);} else {println!("FAILED: {}", name);}failed += 1;}}
    }
    println!("\nRESULTS: {} passed, {} failed", passed, failed);
}